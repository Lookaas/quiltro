{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Lucas\\\\Documents\\\\quiltros\\\\components\\\\canvas\\\\Transformer\\\\index.tsx\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/** @jsx jsx */\nimport { jsx } from '@emotion/core';\nimport React, { createRef } from 'react';\nimport { Transformer } from 'react-konva';\n\nclass TransformerComponent extends React.Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"transformerRef\", createRef());\n\n    _defineProperty(this, \"boundFoxFunction\", (oldBox, newBox) => {\n      const {\n        minWidth\n      } = this.props;\n      const ref = this.transformerRef.current;\n      const stageWidth = ref.getStage().width();\n\n      if (newBox.width > stageWidth - 10) {\n        const maxWidth = Math.min(newBox.width, stageWidth - 10);\n        newBox.width = maxWidth;\n      } else {\n        const width = Math.max(minWidth, newBox.width);\n        newBox.width = width;\n      }\n\n      return newBox;\n    });\n  }\n\n  componentDidMount() {\n    this.checkNode();\n    this.props.onMount(this.transformerRef);\n  }\n\n  componentDidUpdate() {\n    this.checkNode();\n  }\n\n  checkNode() {\n    // We manually attach or detach a node to the Transformer\n    const ref = this.transformerRef.current;\n    const stage = ref.getStage();\n    const {\n      selectedShapeName\n    } = this.props;\n    const selectedNode = stage.findOne('.' + selectedShapeName); // do nothing if the selected node is already attached to the transformer\n\n    if (selectedNode === ref.node()) {\n      return;\n    }\n\n    if (selectedNode) {\n      // attach transformer to another node\n      ref.attachTo(selectedNode);\n    } else {\n      // remove current ref from the fransformer\n      ref.detach();\n    } // Trigger a draw for the layer\n\n\n    ref.getLayer().batchDraw();\n  }\n\n  render() {\n    const _this$props = this.props,\n          {\n      selectedShapeName\n    } = _this$props,\n          rest = _objectWithoutProperties(_this$props, [\"selectedShapeName\"]);\n\n    return jsx(Transformer, _extends({\n      ref: this.transformerRef,\n      enabledAnchors: ['middle-left', 'middle-right'],\n      boundBoxFunc: this.boundFoxFunction\n    }, rest, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 71\n      },\n      __self: this\n    }));\n  }\n\n}\n\n_defineProperty(TransformerComponent, \"defaultProps\", {\n  minWidth: 50\n});\n\nexport default TransformerComponent;","map":{"version":3,"sources":["C:/Users/Lucas/Documents/quiltros/components/canvas/Transformer/index.tsx"],"names":["jsx","React","createRef","Transformer","TransformerComponent","Component","oldBox","newBox","minWidth","props","ref","transformerRef","current","stageWidth","getStage","width","maxWidth","Math","min","max","componentDidMount","checkNode","onMount","componentDidUpdate","stage","selectedShapeName","selectedNode","findOne","node","attachTo","detach","getLayer","batchDraw","render","rest","boundFoxFunction"],"mappings":";;;;;;;;;;;AAAA;AACA,SAASA,GAAT,QAAoB,eAApB;AAEA,OAAOC,KAAP,IAAgBC,SAAhB,QAA4C,OAA5C;AACA,SAASC,WAAT,QAA4B,aAA5B;;AAYA,MAAMC,oBAAN,SAAmCH,KAAK,CAACI,SAAzC,CAA0E;AAAA;AAAA;;AAAA,4CAKvDH,SAAS,EAL8C;;AAAA,8CAqCrD,CAACI,MAAD,EAAcC,MAAd,KAA8B;AAC/C,YAAM;AAAEC,QAAAA;AAAF,UAAe,KAAKC,KAA1B;AACA,YAAMC,GAAG,GAAG,KAAKC,cAAL,CAAoBC,OAAhC;AACA,YAAMC,UAAU,GAAGH,GAAG,CAACI,QAAJ,GAAeC,KAAf,EAAnB;;AACA,UAAIR,MAAM,CAACQ,KAAP,GAAeF,UAAU,GAAG,EAAhC,EAAoC;AAClC,cAAMG,QAAQ,GAAGC,IAAI,CAACC,GAAL,CAASX,MAAM,CAACQ,KAAhB,EAAuBF,UAAU,GAAG,EAApC,CAAjB;AACAN,QAAAA,MAAM,CAACQ,KAAP,GAAeC,QAAf;AACD,OAHD,MAGO;AACL,cAAMD,KAAK,GAAGE,IAAI,CAACE,GAAL,CAASX,QAAT,EAAmBD,MAAM,CAACQ,KAA1B,CAAd;AACAR,QAAAA,MAAM,CAACQ,KAAP,GAAeA,KAAf;AACD;;AACD,aAAOR,MAAP;AACD,KAjDuE;AAAA;;AAOxEa,EAAAA,iBAAiB,GAAG;AAClB,SAAKC,SAAL;AACA,SAAKZ,KAAL,CAAWa,OAAX,CAAmB,KAAKX,cAAxB;AACD;;AAEDY,EAAAA,kBAAkB,GAAG;AACnB,SAAKF,SAAL;AACD;;AAEDA,EAAAA,SAAS,GAAG;AACV;AACA,UAAMX,GAAG,GAAG,KAAKC,cAAL,CAAoBC,OAAhC;AACA,UAAMY,KAAK,GAAGd,GAAG,CAACI,QAAJ,EAAd;AACA,UAAM;AAAEW,MAAAA;AAAF,QAAwB,KAAKhB,KAAnC;AACA,UAAMiB,YAAY,GAAGF,KAAK,CAACG,OAAN,CAAc,MAAMF,iBAApB,CAArB,CALU,CAMV;;AACA,QAAIC,YAAY,KAAKhB,GAAG,CAACkB,IAAJ,EAArB,EAAiC;AAC/B;AACD;;AACD,QAAIF,YAAJ,EAAkB;AAChB;AACAhB,MAAAA,GAAG,CAACmB,QAAJ,CAAaH,YAAb;AACD,KAHD,MAGO;AACL;AACAhB,MAAAA,GAAG,CAACoB,MAAJ;AACD,KAhBS,CAiBV;;;AACApB,IAAAA,GAAG,CAACqB,QAAJ,GAAeC,SAAf;AACD;;AAgBDC,EAAAA,MAAM,GAAG;AACP,wBAAuC,KAAKxB,KAA5C;AAAA,UAAM;AAAEgB,MAAAA;AAAF,KAAN;AAAA,UAA8BS,IAA9B;;AACA,WACE,IAAC,WAAD;AACE,MAAA,GAAG,EAAE,KAAKvB,cADZ;AAEE,MAAA,cAAc,EAAE,CAAC,aAAD,EAAgB,cAAhB,CAFlB;AAGE,MAAA,YAAY,EAAE,KAAKwB;AAHrB,OAIMD,IAJN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OADF;AAQD;;AA7DuE;;gBAApE9B,oB,kBACkB;AACpBI,EAAAA,QAAQ,EAAE;AADU,C;;AA+DxB,eAAeJ,oBAAf","sourcesContent":["/** @jsx jsx */\r\nimport { jsx } from '@emotion/core';\r\nimport Konva from 'konva';\r\nimport React, { createRef, RefObject } from 'react';\r\nimport { Transformer } from 'react-konva';\r\nimport { IRect } from 'konva/types/types';\r\n\r\ninterface Box extends IRect {\r\n  rotation: number;\r\n}\r\n\r\ninterface ITransformerComponent extends Konva.TransformerConfig {\r\n  selectedShapeName: string;\r\n  onMount: (arg1: RefObject<any>) => void;\r\n}\r\n\r\nclass TransformerComponent extends React.Component<ITransformerComponent> {\r\n  static defaultProps = {\r\n    minWidth: 50\r\n  };\r\n\r\n  transformerRef = createRef<any>();\r\n\r\n  componentDidMount() {\r\n    this.checkNode();\r\n    this.props.onMount(this.transformerRef);\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    this.checkNode();\r\n  }\r\n\r\n  checkNode() {\r\n    // We manually attach or detach a node to the Transformer\r\n    const ref = this.transformerRef.current!;\r\n    const stage = ref.getStage();\r\n    const { selectedShapeName } = this.props;\r\n    const selectedNode = stage.findOne('.' + selectedShapeName);\r\n    // do nothing if the selected node is already attached to the transformer\r\n    if (selectedNode === ref.node()) {\r\n      return;\r\n    }\r\n    if (selectedNode) {\r\n      // attach transformer to another node\r\n      ref.attachTo(selectedNode);\r\n    } else {\r\n      // remove current ref from the fransformer\r\n      ref.detach();\r\n    }\r\n    // Trigger a draw for the layer\r\n    ref.getLayer().batchDraw();\r\n  }\r\n\r\n  boundFoxFunction = (oldBox: Box, newBox: Box) => {\r\n    const { minWidth } = this.props;\r\n    const ref = this.transformerRef.current!;\r\n    const stageWidth = ref.getStage().width();\r\n    if (newBox.width > stageWidth - 10) {\r\n      const maxWidth = Math.min(newBox.width, stageWidth - 10);\r\n      newBox.width = maxWidth;\r\n    } else {\r\n      const width = Math.max(minWidth, newBox.width);\r\n      newBox.width = width;\r\n    }\r\n    return newBox;\r\n  };\r\n\r\n  render() {\r\n    const { selectedShapeName, ...rest } = this.props;\r\n    return (\r\n      <Transformer\r\n        ref={this.transformerRef}\r\n        enabledAnchors={['middle-left', 'middle-right']}\r\n        boundBoxFunc={this.boundFoxFunction}\r\n        {...rest}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nexport default TransformerComponent;\r\n"]},"metadata":{},"sourceType":"module"}