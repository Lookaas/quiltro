{"ast":null,"code":"import _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _Object$values from \"@babel/runtime-corejs2/core-js/object/values\";\nimport _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\nimport _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar _jsxFileName = \"C:\\\\Users\\\\Lucas\\\\Documents\\\\quiltros\\\\components\\\\canvas\\\\index.tsx\";\nimport React from \"react\";\nvar __jsx = React.createElement;\n\n/** @jsx jsx */\nimport { Card, Elevation } from '@blueprintjs/core';\nimport { jsx } from '@emotion/core';\nimport { Component, createRef } from 'react';\nimport { Layer, Stage } from 'react-konva';\nimport { Image as ImageKonva } from 'react-konva';\nimport BackgroundImage from './BackgroundImage';\nimport EditTextArea from './TextArea';\nimport { canvasStyle } from './style';\nimport CanvasText from './Text';\nimport TransformerComponent from './Transformer';\nimport dog from '../../assets/dog.svg';\n\nvar Canvas =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(Canvas, _Component);\n\n  function Canvas() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, Canvas);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Canvas)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      backgroundImage: null,\n      canvasHeight: 750,\n      canvasWidth: 500,\n      editTextAreaProps: {},\n      editTextAreaValue: '',\n      onTextAreaClosed: function onTextAreaClosed() {\n        return null;\n      },\n      showEditTextArea: false,\n      targetToRestore: []\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"transformerRef\", createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"resizeImageHeight\", function (img, newHeight, newWidth) {\n      var canvas = document.createElement('canvas');\n      canvas.height = newHeight;\n      canvas.width = newWidth;\n      var ctx = canvas.getContext('2d');\n\n      if (!ctx) {\n        return _Promise.resolve(img);\n      }\n\n      return new _Promise(function (resolve, reject) {\n        ctx.drawImage(img, 0, 0);\n        ctx.drawImage(img, 0, 0, newWidth, newHeight);\n        var dataurl = canvas.toDataURL('image/png');\n        var newImage = new Image();\n        newImage.src = dataurl;\n        newImage.addEventListener('load', function () {\n          resolve(newImage);\n        });\n        newImage.addEventListener('error', function () {\n          reject(img);\n        });\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getResizedImage\", function (image) {\n      var height = image.height,\n          width = image.width;\n      var _this$state = _this.state,\n          canvasHeight = _this$state.canvasHeight,\n          canvasWidth = _this$state.canvasWidth;\n      var imageHeight = height;\n      var imageWidth = width; // Resize to go over the canvas height\n\n      imageWidth = imageWidth * (canvasHeight / imageHeight);\n      imageHeight = canvasHeight; // Resize to go over the canvas width\n\n      if (canvasWidth > imageWidth) {\n        imageHeight = imageHeight * (canvasWidth / imageWidth);\n        imageWidth = canvasWidth;\n      }\n\n      return _this.resizeImageHeight(image, imageHeight, imageWidth);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onTextClick\", function (e) {\n      e.cancelBubble = true;\n      var selectedTextBlock = e.target.name();\n\n      _this.props.onTextBlockSelected(selectedTextBlock);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleStageMouseDown\", function (e) {\n      var showEditTextArea = false;\n      var selectedTextBlock = '';\n      var currentTarget = e.currentTarget;\n      var targetToRestore = _this.state.targetToRestore;\n      var onTextBlockSelected = _this.props.onTextBlockSelected;\n      /*const clickedOnStage = target === currentTarget.getStage();\r\n      //const clickedOnTransformer =\r\n      //  target.getParent() && target.getParent().className === 'Transformer';\r\n      //const hasNoName = Boolean(target.name()); // If the thing we are clicking has no name\r\n      const isTextNode = typeof e.currentTarget.stat === 'function'; // TODO: maybe remove this?\r\n      if (isTextNode) {\r\n        selectedTextBlock = e.target.name;\r\n      }*/\n\n      if (targetToRestore) {\n        targetToRestore.forEach(function (el) {\n          var canvasRef = _this.props.canvasRef.current;\n          el.show();\n          canvasRef.draw();\n        });\n      }\n\n      _this.setState({\n        showEditTextArea: showEditTextArea\n      }, function () {\n        return onTextBlockSelected(selectedTextBlock);\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"showElements\", function (currentTarget) {\n      return function () {\n        _this.setState({\n          showEditTextArea: false\n        }, function () {\n          currentTarget.hide();\n          var transformerRef = _this.transformerRef.current;\n          var canvasRef = _this.props.canvasRef.current;\n          currentTarget.show();\n          transformerRef.show();\n          canvasRef.draw();\n        });\n      };\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"hideElements\", function (currentTarget) {\n      currentTarget.hide();\n      var transformerRef = _this.transformerRef.current;\n      var canvasRef = _this.props.canvasRef.current;\n      currentTarget.hide();\n      transformerRef.hide();\n      canvasRef.draw();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onMouseDown\", function (evt) {\n      var onTextBlockSelected = _this.props.onTextBlockSelected;\n      evt.cancelBubble = true;\n      var currentTarget = evt.target;\n      var id = currentTarget.attrs.id;\n      onTextBlockSelected(id);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onDoubleClick\", function (evt) {\n      var currentTarget = evt.currentTarget;\n      var transformerRef = _this.transformerRef.current;\n      var canvasRef = _this.props.canvasRef.current;\n\n      _this.hideElements(currentTarget); // We will create a textarea absolutely positioned over the canvas\n      // And we will render it on a portal\n      // first we need to find position for textarea\n      // At first lets find position of text node relative to the stage:\n\n\n      var _currentTarget$absolu = currentTarget.absolutePosition(),\n          x = _currentTarget$absolu.x,\n          y = _currentTarget$absolu.y;\n\n      var _canvasRef$container$ = canvasRef.container().getBoundingClientRect(),\n          left = _canvasRef$container$.left,\n          top = _canvasRef$container$.top; // so position of textarea will be the sum of positions above:\n\n\n      var areaPosition = {\n        x: left + x,\n        y: top + y\n      }; // Create textarea styles to match text on canvas as close as possible\n      // (Text rendering on canvas and on the textarea can be different\n      // and sometimes it is hard to make it 100% the same)\n\n      var targetToRestore = [currentTarget, transformerRef];\n      var showEditTextArea = true;\n      var editTextAreaValue = currentTarget.text();\n      var editTextAreaProps = {\n        color: currentTarget.fill() + '',\n        fontFamily: currentTarget.fontFamily() + '',\n        fontSize: currentTarget.fontSize() + 'px',\n        height: currentTarget.height() + 'px',\n        left: areaPosition.x + 'px',\n        lineHeight: currentTarget.lineHeight() + '',\n        padding: currentTarget.padding() + 'px',\n        textAlign: currentTarget.align() + '',\n        top: areaPosition.y + 'px',\n        transformOrigin: 'left top',\n        width: currentTarget.width() + 5 + 'px'\n      };\n\n      var onTextAreaClosed = _this.showElements(currentTarget);\n\n      _this.setState({\n        editTextAreaProps: editTextAreaProps,\n        editTextAreaValue: editTextAreaValue,\n        onTextAreaClosed: onTextAreaClosed,\n        showEditTextArea: showEditTextArea,\n        targetToRestore: targetToRestore\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onMount\", function (ref) {\n      _this.transformerRef = ref;\n    });\n\n    return _this;\n  }\n\n  _createClass(Canvas, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var image, backgroundImage;\n      return _regeneratorRuntime.async(function componentDidUpdate$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              image = this.props.image;\n\n              if (!(image && image !== prevProps.image)) {\n                _context.next = 6;\n                break;\n              }\n\n              _context.next = 4;\n              return _regeneratorRuntime.awrap(this.getResizedImage(image));\n\n            case 4:\n              backgroundImage = _context.sent;\n              this.setState({\n                backgroundImage: backgroundImage\n              });\n\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$state2 = this.state,\n          backgroundImage = _this$state2.backgroundImage,\n          canvasHeight = _this$state2.canvasHeight,\n          canvasWidth = _this$state2.canvasWidth,\n          showEditTextArea = _this$state2.showEditTextArea,\n          editTextAreaProps = _this$state2.editTextAreaProps,\n          onTextAreaClosed = _this$state2.onTextAreaClosed;\n      var _this$props = this.props,\n          canvasTexts = _this$props.canvasTexts,\n          onRef = _this$props.onRef,\n          onTextChanged = _this$props.onTextChanged;\n      var textBlocks = canvasTexts.textBlocks,\n          selectedTextBlock = canvasTexts.selectedTextBlock;\n      return jsx(Card, {\n        elevation: Elevation.ONE,\n        css: canvasStyle,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 237\n        },\n        __self: this\n      }, true && jsx(Stage, {\n        ref: onRef,\n        width: canvasWidth,\n        height: canvasHeight,\n        onClick: this.handleStageMouseDown,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 239\n        },\n        __self: this\n      }, jsx(BackgroundImage, {\n        backgroundImage: backgroundImage,\n        canvasHeight: canvasHeight,\n        canvasWidth: canvasWidth,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 245\n        },\n        __self: this\n      }), jsx(Layer, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 250\n        },\n        __self: this\n      }, _Object$values(textBlocks).map(function (textBlock) {\n        return jsx(CanvasText, _extends({\n          key: textBlock.id\n        }, textBlock, {\n          position: {\n            x: 0,\n            y: 0\n          },\n          maxHeight: canvasHeight,\n          maxWidth: canvasWidth,\n          onClick: _this2.onTextClick,\n          onDoubleClick: _this2.onDoubleClick,\n          onMouseDown: _this2.onMouseDown,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 252\n          },\n          __self: this\n        }));\n      }), jsx(ImageKonva, {\n        image: dog,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 263\n        },\n        __self: this\n      }), jsx(TransformerComponent, {\n        resizeEnabled: true,\n        rotateEnabled: false,\n        borderEnabled: true,\n        onMount: this.onMount,\n        selectedShapeName: selectedTextBlock,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 264\n        },\n        __self: this\n      }))), showEditTextArea && textBlocks[selectedTextBlock].text && jsx(EditTextArea, {\n        onTextAreaClosed: onTextAreaClosed,\n        onTextAreaChanged: onTextChanged,\n        selectedtextblockid: selectedTextBlock,\n        value: textBlocks[selectedTextBlock].text,\n        style: editTextAreaProps,\n        maxWidth: canvasWidth,\n        maxHeight: canvasHeight,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 275\n        },\n        __self: this\n      }));\n    }\n  }]);\n\n  return Canvas;\n}(Component);\n\nexport default Canvas;","map":{"version":3,"sources":["C:/Users/Lucas/Documents/quiltros/components/canvas/index.tsx"],"names":["Card","Elevation","jsx","Component","createRef","Layer","Stage","Image","ImageKonva","BackgroundImage","EditTextArea","canvasStyle","CanvasText","TransformerComponent","dog","Canvas","backgroundImage","canvasHeight","canvasWidth","editTextAreaProps","editTextAreaValue","onTextAreaClosed","showEditTextArea","targetToRestore","img","newHeight","newWidth","canvas","document","createElement","height","width","ctx","getContext","resolve","reject","drawImage","dataurl","toDataURL","newImage","src","addEventListener","image","state","imageHeight","imageWidth","resizeImageHeight","e","cancelBubble","selectedTextBlock","target","name","props","onTextBlockSelected","currentTarget","forEach","el","canvasRef","current","show","draw","setState","hide","transformerRef","evt","id","attrs","hideElements","absolutePosition","x","y","container","getBoundingClientRect","left","top","areaPosition","text","color","fill","fontFamily","fontSize","lineHeight","padding","textAlign","align","transformOrigin","showElements","ref","prevProps","getResizedImage","canvasTexts","onRef","onTextChanged","textBlocks","ONE","handleStageMouseDown","map","textBlock","onTextClick","onDoubleClick","onMouseDown","onMount"],"mappings":"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","sourcesContent":["/** @jsx jsx */\r\nimport { Card, Elevation } from '@blueprintjs/core';\r\nimport { jsx } from '@emotion/core';\r\nimport { KonvaEventObject } from 'konva/types/Node';\r\nimport Konva from 'konva'\r\nimport React, { Component, createRef, RefObject } from 'react';\r\nimport { Layer, Stage } from 'react-konva';\r\nimport { Image as ImageKonva } from 'react-konva';\r\n\r\nimport { ICanvasTexts } from '../../pages';\r\nimport { ITextBlocksConfigPanelState } from '../LeftSideBar/TextBlocksCreator/panel';\r\nimport BackgroundImage from './BackgroundImage';\r\nimport EditTextArea from './TextArea';\r\nimport { canvasStyle } from './style';\r\nimport CanvasText from './Text';\r\nimport TransformerComponent from './Transformer';\r\nimport dog from '../../assets/dog.svg'\r\n\r\ninterface IAppProps {\r\n  onRef: RefObject<any>;\r\n  canvasRef: RefObject<any>;\r\n  onTextBlockSelected: (arg1: string) => void;\r\n  image: HTMLImageElement | null;\r\n  canvasTexts: ICanvasTexts;\r\n  onTextChanged: (arg1: string, arg2: string) => void;\r\n  currentCanvasText: ITextBlocksConfigPanelState;\r\n}\r\n\r\ninterface IAppState {\r\n  showEditTextArea: boolean;\r\n  backgroundImage: HTMLImageElement | null;\r\n  editTextAreaProps: any;\r\n  onTextAreaClosed: () => void;\r\n  targetToRestore: any[];\r\n  editTextAreaValue: string;\r\n}\r\nclass Canvas extends Component<IAppProps, IAppState> {\r\n  state = {\r\n    backgroundImage: null,\r\n    canvasHeight: 750,\r\n    canvasWidth: 500,\r\n    editTextAreaProps: {},\r\n    editTextAreaValue: '',\r\n    onTextAreaClosed: () => null,\r\n    showEditTextArea: false,\r\n    targetToRestore: []\r\n  };\r\n\r\n  transformerRef = createRef<any>();\r\n\r\n  resizeImageHeight = (img: HTMLImageElement, newHeight: number, newWidth: number): Promise<HTMLImageElement> => {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.height = newHeight;\r\n    canvas.width = newWidth;\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx) {\r\n      return Promise.resolve(img);\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      ctx.drawImage(img, 0, 0);\r\n      ctx.drawImage(img, 0, 0, newWidth, newHeight);\r\n      const dataurl = canvas.toDataURL('image/png');\r\n\r\n      const newImage = new Image();\r\n      newImage.src = dataurl;\r\n      newImage.addEventListener('load', () => {\r\n        resolve(newImage);\r\n      });\r\n      newImage.addEventListener('error', () => {\r\n        reject(img);\r\n      });\r\n    });\r\n  };\r\n\r\n  getResizedImage = (image: HTMLImageElement) => {\r\n    const { height, width } = image;\r\n    const { canvasHeight, canvasWidth } = this.state;\r\n    let imageHeight = height;\r\n    let imageWidth = width;\r\n    // Resize to go over the canvas height\r\n    imageWidth = imageWidth * (canvasHeight / imageHeight);\r\n    imageHeight = canvasHeight;\r\n\r\n    // Resize to go over the canvas width\r\n    if (canvasWidth > imageWidth) {\r\n      imageHeight = imageHeight * (canvasWidth / imageWidth);\r\n      imageWidth = canvasWidth;\r\n    }\r\n    return this.resizeImageHeight(image, imageHeight, imageWidth);\r\n  };\r\n\r\n  async componentDidUpdate(prevProps: any) {\r\n    const { image } = this.props;\r\n    if (image && image !== prevProps.image) {\r\n      const backgroundImage = await this.getResizedImage(image);\r\n      this.setState({ backgroundImage });\r\n    }\r\n  }\r\n\r\n  onTextClick = (e:Konva.KonvaEventObject<MouseEvent>): void => {\r\n    e.cancelBubble = true;\r\n    const selectedTextBlock = e.target.name();\r\n    this.props.onTextBlockSelected(selectedTextBlock);\r\n  };\r\n\r\n  handleStageMouseDown = (e: Konva.KonvaEventObject<MouseEvent>) => {\r\n    const showEditTextArea = false;\r\n    let selectedTextBlock = '';\r\n    const { currentTarget } = e;\r\n    const { targetToRestore } = this.state;\r\n    const { onTextBlockSelected } = this.props;\r\n    /*const clickedOnStage = target === currentTarget.getStage();\r\n    //const clickedOnTransformer =\r\n    //  target.getParent() && target.getParent().className === 'Transformer';\r\n    //const hasNoName = Boolean(target.name()); // If the thing we are clicking has no name\r\n    const isTextNode = typeof e.currentTarget.stat === 'function'; // TODO: maybe remove this?\r\n    if (isTextNode) {\r\n      selectedTextBlock = e.target.name;\r\n    }*/\r\n\r\n    if (targetToRestore) {\r\n      targetToRestore.forEach((el: any) => {\r\n        const canvasRef = this.props.canvasRef.current!;\r\n        el.show();\r\n        canvasRef.draw();\r\n      });\r\n    }\r\n\r\n    this.setState(\r\n      {\r\n        showEditTextArea\r\n      },\r\n      () => onTextBlockSelected(selectedTextBlock)\r\n    );\r\n  };\r\n\r\n  showElements = (currentTarget: any) => () => {\r\n    this.setState(\r\n      {\r\n        showEditTextArea: false\r\n      },\r\n      () => {\r\n        currentTarget.hide();\r\n        const transformerRef = this.transformerRef.current!;\r\n        const canvasRef = this.props.canvasRef.current!;\r\n        currentTarget.show();\r\n        transformerRef.show();\r\n        canvasRef.draw();\r\n      }\r\n    );\r\n  };\r\n\r\n  hideElements = (currentTarget: any) => {\r\n    currentTarget.hide();\r\n    const transformerRef = this.transformerRef.current!;\r\n    const canvasRef = this.props.canvasRef.current!;\r\n    currentTarget.hide();\r\n    transformerRef.hide();\r\n    canvasRef.draw();\r\n  };\r\n\r\n  onMouseDown = (evt: KonvaEventObject<MouseEvent>): void => {\r\n    const { onTextBlockSelected } = this.props;\r\n    evt.cancelBubble = true;\r\n    const currentTarget: any = evt.target;\r\n    const { id } = currentTarget.attrs;\r\n    onTextBlockSelected(id);\r\n  };\r\n\r\n  onDoubleClick = (evt: KonvaEventObject<MouseEvent>): void => {\r\n    const currentTarget: any = evt.currentTarget;\r\n    const transformerRef = this.transformerRef.current!;\r\n    const canvasRef = this.props.canvasRef.current!;\r\n    this.hideElements(currentTarget);\r\n\r\n    // We will create a textarea absolutely positioned over the canvas\r\n    // And we will render it on a portal\r\n    // first we need to find position for textarea\r\n\r\n    // At first lets find position of text node relative to the stage:\r\n    const { x, y } = currentTarget.absolutePosition();\r\n    const { left, top } = canvasRef.container().getBoundingClientRect();\r\n\r\n    // so position of textarea will be the sum of positions above:\r\n    const areaPosition = {\r\n      x: left + x,\r\n      y: top + y\r\n    };\r\n\r\n    // Create textarea styles to match text on canvas as close as possible\r\n    // (Text rendering on canvas and on the textarea can be different\r\n    // and sometimes it is hard to make it 100% the same)\r\n    const targetToRestore = [currentTarget, transformerRef];\r\n    const showEditTextArea = true;\r\n    const editTextAreaValue = currentTarget.text();\r\n    const editTextAreaProps = {\r\n      color: currentTarget.fill() + '',\r\n      fontFamily: currentTarget.fontFamily() + '',\r\n      fontSize: currentTarget.fontSize() + 'px',\r\n      height: currentTarget.height() + 'px',\r\n      left: areaPosition.x + 'px',\r\n      lineHeight: currentTarget.lineHeight() + '',\r\n      padding: currentTarget.padding() + 'px',\r\n      textAlign: currentTarget.align() + '',\r\n      top: areaPosition.y + 'px',\r\n      transformOrigin: 'left top',\r\n      width: currentTarget.width() + 5 + 'px'\r\n    };\r\n\r\n    const onTextAreaClosed = this.showElements(currentTarget);\r\n\r\n    this.setState({\r\n      editTextAreaProps,\r\n      editTextAreaValue,\r\n      onTextAreaClosed,\r\n      showEditTextArea,\r\n      targetToRestore\r\n    });\r\n  };\r\n\r\n  onMount = (ref : RefObject<any>) => {\r\n    this.transformerRef = ref;\r\n  };\r\n\r\n  render() {\r\n    const {\r\n      backgroundImage,\r\n      canvasHeight,\r\n      canvasWidth,\r\n      showEditTextArea,\r\n      editTextAreaProps,\r\n      onTextAreaClosed\r\n    } = this.state;\r\n    const { canvasTexts, onRef, onTextChanged } = this.props;\r\n    const { textBlocks, selectedTextBlock } = canvasTexts;\r\n    return (\r\n      <Card elevation={Elevation.ONE} css={canvasStyle}>\r\n        {process.browser && (\r\n          <Stage\r\n            ref={onRef}\r\n            width={canvasWidth}\r\n            height={canvasHeight}\r\n            onClick={this.handleStageMouseDown}\r\n          >\r\n            <BackgroundImage\r\n              backgroundImage={backgroundImage}\r\n              canvasHeight={canvasHeight}\r\n              canvasWidth={canvasWidth}\r\n            />\r\n            <Layer>\r\n              {Object.values(textBlocks).map(textBlock => (\r\n                <CanvasText\r\n                  key={textBlock.id}\r\n                  {...textBlock}\r\n                  position={{ x: 0, y: 0 }}\r\n                  maxHeight={canvasHeight}\r\n                  maxWidth={canvasWidth}\r\n                  onClick={this.onTextClick}\r\n                  onDoubleClick={this.onDoubleClick}\r\n                  onMouseDown={this.onMouseDown}\r\n                />\r\n              ))}\r\n              <ImageKonva image={dog as SVGImageElement} />\r\n              <TransformerComponent\r\n                resizeEnabled\r\n                rotateEnabled={false}\r\n                borderEnabled\r\n                onMount={this.onMount}\r\n                selectedShapeName={selectedTextBlock}\r\n              />\r\n            </Layer>\r\n          </Stage>\r\n        )}\r\n        {showEditTextArea && textBlocks[selectedTextBlock].text && (\r\n          <EditTextArea\r\n            onTextAreaClosed={onTextAreaClosed}\r\n            onTextAreaChanged={onTextChanged}\r\n            selectedtextblockid={selectedTextBlock}\r\n            value={textBlocks[selectedTextBlock].text}\r\n            style={editTextAreaProps}\r\n            maxWidth={canvasWidth}\r\n            maxHeight={canvasHeight}\r\n          />\r\n        )}\r\n      </Card>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Canvas;\r\n"]},"metadata":{},"sourceType":"module"}