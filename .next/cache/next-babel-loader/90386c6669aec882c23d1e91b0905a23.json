{"ast":null,"code":"import _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime-corejs2/helpers/esm/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar _jsxFileName = \"C:\\\\Users\\\\Lucas\\\\Documents\\\\quiltros\\\\components\\\\canvas\\\\Transformer\\\\index.tsx\";\nvar __jsx = React.createElement;\n\n/** @jsx jsx */\nimport { jsx } from '@emotion/core';\nimport React, { createRef } from 'react';\nimport { Transformer } from 'react-konva';\n\nvar TransformerComponent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(TransformerComponent, _React$Component);\n\n  function TransformerComponent() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, TransformerComponent);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TransformerComponent)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_this), \"transformerRef\", createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"boundFoxFunction\", function (oldBox, newBox) {\n      var minWidth = _this.props.minWidth;\n      var ref = _this.transformerRef.current;\n      var stageWidth = ref.getStage().width();\n\n      if (newBox.width > stageWidth - 10) {\n        var maxWidth = Math.min(newBox.width, stageWidth - 10);\n        newBox.width = maxWidth;\n      } else {\n        var width = Math.max(minWidth, newBox.width);\n        newBox.width = width;\n      }\n\n      return newBox;\n    });\n\n    return _this;\n  }\n\n  _createClass(TransformerComponent, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.checkNode();\n      this.props.onMount(this.transformerRef);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.checkNode();\n    }\n  }, {\n    key: \"checkNode\",\n    value: function checkNode() {\n      // We manually attach or detach a node to the Transformer\n      var ref = this.transformerRef.current;\n      var stage = ref.getStage();\n      var selectedShapeName = this.props.selectedShapeName;\n      var selectedNode = stage.findOne('.' + selectedShapeName); // do nothing if the selected node is already attached to the transformer\n\n      if (selectedNode === ref.node()) {\n        return;\n      }\n\n      if (selectedNode) {\n        // attach transformer to another node\n        ref.attachTo(selectedNode);\n      } else {\n        // remove current ref from the fransformer\n        ref.detach();\n      } // Trigger a draw for the layer\n\n\n      ref.getLayer().batchDraw();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          selectedShapeName = _this$props.selectedShapeName,\n          rest = _objectWithoutProperties(_this$props, [\"selectedShapeName\"]);\n\n      return jsx(Transformer, _extends({\n        ref: this.transformerRef,\n        enabledAnchors: ['middle-left', 'middle-right'],\n        boundBoxFunc: this.boundFoxFunction\n      }, rest, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 71\n        },\n        __self: this\n      }));\n    }\n  }]);\n\n  return TransformerComponent;\n}(React.Component);\n\n_defineProperty(TransformerComponent, \"defaultProps\", {\n  minWidth: 50\n});\n\nexport default TransformerComponent;","map":{"version":3,"sources":["C:/Users/Lucas/Documents/quiltros/components/canvas/Transformer/index.tsx"],"names":["jsx","React","createRef","Transformer","TransformerComponent","oldBox","newBox","minWidth","props","ref","transformerRef","current","stageWidth","getStage","width","maxWidth","Math","min","max","checkNode","onMount","stage","selectedShapeName","selectedNode","findOne","node","attachTo","detach","getLayer","batchDraw","rest","boundFoxFunction","Component"],"mappings":";;;;;;;;;;;;AAAA;AACA,SAASA,GAAT,QAAoB,eAApB;AAEA,OAAOC,KAAP,IAAgBC,SAAhB,QAA4C,OAA5C;AACA,SAASC,WAAT,QAA4B,aAA5B;;IAYMC,oB;;;;;;;;;;;;;;;;;;qEAKaF,SAAS,E;;uEAgCP,UAACG,MAAD,EAAcC,MAAd,EAA8B;AAAA,UACvCC,QADuC,GAC1B,MAAKC,KADqB,CACvCD,QADuC;AAE/C,UAAME,GAAG,GAAG,MAAKC,cAAL,CAAoBC,OAAhC;AACA,UAAMC,UAAU,GAAGH,GAAG,CAACI,QAAJ,GAAeC,KAAf,EAAnB;;AACA,UAAIR,MAAM,CAACQ,KAAP,GAAeF,UAAU,GAAG,EAAhC,EAAoC;AAClC,YAAMG,QAAQ,GAAGC,IAAI,CAACC,GAAL,CAASX,MAAM,CAACQ,KAAhB,EAAuBF,UAAU,GAAG,EAApC,CAAjB;AACAN,QAAAA,MAAM,CAACQ,KAAP,GAAeC,QAAf;AACD,OAHD,MAGO;AACL,YAAMD,KAAK,GAAGE,IAAI,CAACE,GAAL,CAASX,QAAT,EAAmBD,MAAM,CAACQ,KAA1B,CAAd;AACAR,QAAAA,MAAM,CAACQ,KAAP,GAAeA,KAAf;AACD;;AACD,aAAOR,MAAP;AACD,K;;;;;;;wCA1CmB;AAClB,WAAKa,SAAL;AACA,WAAKX,KAAL,CAAWY,OAAX,CAAmB,KAAKV,cAAxB;AACD;;;yCAEoB;AACnB,WAAKS,SAAL;AACD;;;gCAEW;AACV;AACA,UAAMV,GAAG,GAAG,KAAKC,cAAL,CAAoBC,OAAhC;AACA,UAAMU,KAAK,GAAGZ,GAAG,CAACI,QAAJ,EAAd;AAHU,UAIFS,iBAJE,GAIoB,KAAKd,KAJzB,CAIFc,iBAJE;AAKV,UAAMC,YAAY,GAAGF,KAAK,CAACG,OAAN,CAAc,MAAMF,iBAApB,CAArB,CALU,CAMV;;AACA,UAAIC,YAAY,KAAKd,GAAG,CAACgB,IAAJ,EAArB,EAAiC;AAC/B;AACD;;AACD,UAAIF,YAAJ,EAAkB;AAChB;AACAd,QAAAA,GAAG,CAACiB,QAAJ,CAAaH,YAAb;AACD,OAHD,MAGO;AACL;AACAd,QAAAA,GAAG,CAACkB,MAAJ;AACD,OAhBS,CAiBV;;;AACAlB,MAAAA,GAAG,CAACmB,QAAJ,GAAeC,SAAf;AACD;;;6BAgBQ;AAAA,wBACgC,KAAKrB,KADrC;AAAA,UACCc,iBADD,eACCA,iBADD;AAAA,UACuBQ,IADvB;;AAEP,aACE,IAAC,WAAD;AACE,QAAA,GAAG,EAAE,KAAKpB,cADZ;AAEE,QAAA,cAAc,EAAE,CAAC,aAAD,EAAgB,cAAhB,CAFlB;AAGE,QAAA,YAAY,EAAE,KAAKqB;AAHrB,SAIMD,IAJN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SADF;AAQD;;;;EA7DgC7B,KAAK,CAAC+B,S;;gBAAnC5B,oB,kBACkB;AACpBG,EAAAA,QAAQ,EAAE;AADU,C;;AA+DxB,eAAeH,oBAAf","sourcesContent":["/** @jsx jsx */\r\nimport { jsx } from '@emotion/core';\r\nimport Konva from 'konva';\r\nimport React, { createRef, RefObject } from 'react';\r\nimport { Transformer } from 'react-konva';\r\nimport { IRect } from 'konva/types/types';\r\n\r\ninterface Box extends IRect {\r\n  rotation: number;\r\n}\r\n\r\ninterface ITransformerComponent extends Konva.TransformerConfig {\r\n  selectedShapeName: string;\r\n  onMount: (arg1: RefObject<any>) => void;\r\n}\r\n\r\nclass TransformerComponent extends React.Component<ITransformerComponent> {\r\n  static defaultProps = {\r\n    minWidth: 50\r\n  };\r\n\r\n  transformerRef = createRef<any>();\r\n\r\n  componentDidMount() {\r\n    this.checkNode();\r\n    this.props.onMount(this.transformerRef);\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    this.checkNode();\r\n  }\r\n\r\n  checkNode() {\r\n    // We manually attach or detach a node to the Transformer\r\n    const ref = this.transformerRef.current!;\r\n    const stage = ref.getStage();\r\n    const { selectedShapeName } = this.props;\r\n    const selectedNode = stage.findOne('.' + selectedShapeName);\r\n    // do nothing if the selected node is already attached to the transformer\r\n    if (selectedNode === ref.node()) {\r\n      return;\r\n    }\r\n    if (selectedNode) {\r\n      // attach transformer to another node\r\n      ref.attachTo(selectedNode);\r\n    } else {\r\n      // remove current ref from the fransformer\r\n      ref.detach();\r\n    }\r\n    // Trigger a draw for the layer\r\n    ref.getLayer().batchDraw();\r\n  }\r\n\r\n  boundFoxFunction = (oldBox: Box, newBox: Box) => {\r\n    const { minWidth } = this.props;\r\n    const ref = this.transformerRef.current!;\r\n    const stageWidth = ref.getStage().width();\r\n    if (newBox.width > stageWidth - 10) {\r\n      const maxWidth = Math.min(newBox.width, stageWidth - 10);\r\n      newBox.width = maxWidth;\r\n    } else {\r\n      const width = Math.max(minWidth, newBox.width);\r\n      newBox.width = width;\r\n    }\r\n    return newBox;\r\n  };\r\n\r\n  render() {\r\n    const { selectedShapeName, ...rest } = this.props;\r\n    return (\r\n      <Transformer\r\n        ref={this.transformerRef}\r\n        enabledAnchors={['middle-left', 'middle-right']}\r\n        boundBoxFunc={this.boundFoxFunction}\r\n        {...rest}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nexport default TransformerComponent;\r\n"]},"metadata":{},"sourceType":"module"}