{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Lucas\\\\Documents\\\\quiltros\\\\components\\\\canvas\\\\index.tsx\";\nimport React from \"react\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/** @jsx jsx */\nimport { Card, Elevation } from '@blueprintjs/core';\nimport { jsx } from '@emotion/core';\nimport { Component, createRef } from 'react';\nimport { Layer, Stage, Path } from 'react-konva';\nimport BackgroundImage from './BackgroundImage';\nimport EditTextArea from './TextArea';\nimport { canvasStyle } from './style';\nimport CanvasText from './Text';\nimport TransformerComponent from './Transformer';\nimport { dog } from '../../assets/icons';\n\nclass Canvas extends Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", {\n      backgroundImage: null,\n      canvasHeight: 750,\n      canvasWidth: 500,\n      editTextAreaProps: {},\n      editTextAreaValue: '',\n      onTextAreaClosed: () => null,\n      showEditTextArea: false,\n      targetToRestore: []\n    });\n\n    _defineProperty(this, \"transformerRef\", createRef());\n\n    _defineProperty(this, \"resizeImageHeight\", (img, newHeight, newWidth) => {\n      const canvas = document.createElement('canvas');\n      canvas.height = newHeight;\n      canvas.width = newWidth;\n      const ctx = canvas.getContext('2d');\n\n      if (!ctx) {\n        return Promise.resolve(img);\n      }\n\n      return new Promise((resolve, reject) => {\n        ctx.drawImage(img, 0, 0);\n        ctx.drawImage(img, 0, 0, newWidth, newHeight);\n        const dataurl = canvas.toDataURL('image/png');\n        const newImage = new Image();\n        newImage.src = dataurl;\n        newImage.addEventListener('load', () => {\n          resolve(newImage);\n        });\n        newImage.addEventListener('error', () => {\n          reject(img);\n        });\n      });\n    });\n\n    _defineProperty(this, \"getResizedImage\", image => {\n      const {\n        height,\n        width\n      } = image;\n      const {\n        canvasHeight,\n        canvasWidth\n      } = this.state;\n      let imageHeight = height;\n      let imageWidth = width; // Resize to go over the canvas height\n\n      imageWidth = imageWidth * (canvasHeight / imageHeight);\n      imageHeight = canvasHeight; // Resize to go over the canvas width\n\n      if (canvasWidth > imageWidth) {\n        imageHeight = imageHeight * (canvasWidth / imageWidth);\n        imageWidth = canvasWidth;\n      }\n\n      return this.resizeImageHeight(image, imageHeight, imageWidth);\n    });\n\n    _defineProperty(this, \"onTextClick\", e => {\n      e.cancelBubble = true;\n      const selectedTextBlock = e.target.name();\n      this.props.onTextBlockSelected(selectedTextBlock);\n    });\n\n    _defineProperty(this, \"handleStageMouseDown\", e => {\n      const showEditTextArea = false;\n      let selectedTextBlock = '';\n      const {\n        currentTarget\n      } = e;\n      const {\n        targetToRestore\n      } = this.state;\n      const {\n        onTextBlockSelected\n      } = this.props;\n      /*const clickedOnStage = target === currentTarget.getStage();\r\n      //const clickedOnTransformer =\r\n      //  target.getParent() && target.getParent().className === 'Transformer';\r\n      //const hasNoName = Boolean(target.name()); // If the thing we are clicking has no name\r\n      const isTextNode = typeof e.currentTarget.stat === 'function'; // TODO: maybe remove this?\r\n      if (isTextNode) {\r\n        selectedTextBlock = e.target.name;\r\n      }*/\n\n      if (targetToRestore) {\n        targetToRestore.forEach(el => {\n          const canvasRef = this.props.canvasRef.current;\n          el.show();\n          canvasRef.draw();\n        });\n      }\n\n      this.setState({\n        showEditTextArea\n      }, () => onTextBlockSelected(selectedTextBlock));\n    });\n\n    _defineProperty(this, \"showElements\", currentTarget => () => {\n      this.setState({\n        showEditTextArea: false\n      }, () => {\n        currentTarget.hide();\n        const transformerRef = this.transformerRef.current;\n        const canvasRef = this.props.canvasRef.current;\n        currentTarget.show();\n        transformerRef.show();\n        canvasRef.draw();\n      });\n    });\n\n    _defineProperty(this, \"hideElements\", currentTarget => {\n      currentTarget.hide();\n      const transformerRef = this.transformerRef.current;\n      const canvasRef = this.props.canvasRef.current;\n      currentTarget.hide();\n      transformerRef.hide();\n      canvasRef.draw();\n    });\n\n    _defineProperty(this, \"onMouseDown\", evt => {\n      const {\n        onTextBlockSelected\n      } = this.props;\n      evt.cancelBubble = true;\n      const currentTarget = evt.target;\n      const {\n        id\n      } = currentTarget.attrs;\n      onTextBlockSelected(id);\n    });\n\n    _defineProperty(this, \"onDoubleClick\", evt => {\n      const currentTarget = evt.currentTarget;\n      const transformerRef = this.transformerRef.current;\n      const canvasRef = this.props.canvasRef.current;\n      this.hideElements(currentTarget); // We will create a textarea absolutely positioned over the canvas\n      // And we will render it on a portal\n      // first we need to find position for textarea\n      // At first lets find position of text node relative to the stage:\n\n      const {\n        x,\n        y\n      } = currentTarget.absolutePosition();\n      const {\n        left,\n        top\n      } = canvasRef.container().getBoundingClientRect(); // so position of textarea will be the sum of positions above:\n\n      const areaPosition = {\n        x: left + x,\n        y: top + y\n      }; // Create textarea styles to match text on canvas as close as possible\n      // (Text rendering on canvas and on the textarea can be different\n      // and sometimes it is hard to make it 100% the same)\n\n      const targetToRestore = [currentTarget, transformerRef];\n      const showEditTextArea = true;\n      const editTextAreaValue = currentTarget.text();\n      const editTextAreaProps = {\n        color: currentTarget.fill() + '',\n        fontFamily: currentTarget.fontFamily() + '',\n        fontSize: currentTarget.fontSize() + 'px',\n        height: currentTarget.height() + 'px',\n        left: areaPosition.x + 'px',\n        lineHeight: currentTarget.lineHeight() + '',\n        padding: currentTarget.padding() + 'px',\n        textAlign: currentTarget.align() + '',\n        top: areaPosition.y + 'px',\n        transformOrigin: 'left top',\n        width: currentTarget.width() + 5 + 'px'\n      };\n      const onTextAreaClosed = this.showElements(currentTarget);\n      this.setState({\n        editTextAreaProps,\n        editTextAreaValue,\n        onTextAreaClosed,\n        showEditTextArea,\n        targetToRestore\n      });\n    });\n\n    _defineProperty(this, \"onMount\", ref => {\n      this.transformerRef = ref;\n    });\n  }\n\n  async componentDidUpdate(prevProps) {\n    const {\n      image\n    } = this.props;\n\n    if (image && image !== prevProps.image) {\n      const backgroundImage = await this.getResizedImage(image);\n      this.setState({\n        backgroundImage\n      });\n    }\n  }\n\n  render() {\n    const {\n      backgroundImage,\n      canvasHeight,\n      canvasWidth,\n      showEditTextArea,\n      editTextAreaProps,\n      onTextAreaClosed\n    } = this.state;\n    const {\n      canvasTexts,\n      onRef,\n      onTextChanged\n    } = this.props;\n    const {\n      textBlocks,\n      selectedTextBlock\n    } = canvasTexts; //const test = '<svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"venus\" class=\"svg-inline--fa fa-venus fa-w-9\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 288 512\"><path fill=\"currentColor\" d=\"M288 176c0-79.5-64.5-144-144-144S0 96.5 0 176c0 68.5 47.9 125.9 112 140.4V368H76c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h36v36c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12v-36h36c6.6 0 12-5.4 12-12v-40c0-6.6-5.4-12-12-12h-36v-51.6c64.1-14.5 112-71.9 112-140.4zm-224 0c0-44.1 35.9-80 80-80s80 35.9 80 80-35.9 80-80 80-80-35.9-80-80z\"></path></svg>'\n\n    return jsx(Card, {\n      elevation: Elevation.ONE,\n      css: canvasStyle,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 238\n      },\n      __self: this\n    }, false && jsx(Stage, {\n      ref: onRef,\n      width: canvasWidth,\n      height: canvasHeight,\n      onClick: this.handleStageMouseDown,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 240\n      },\n      __self: this\n    }, jsx(BackgroundImage, {\n      backgroundImage: backgroundImage,\n      canvasHeight: canvasHeight,\n      canvasWidth: canvasWidth,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 246\n      },\n      __self: this\n    }), jsx(Layer, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 251\n      },\n      __self: this\n    }, Object.values(textBlocks).map(textBlock => jsx(CanvasText, _extends({\n      key: textBlock.id\n    }, textBlock, {\n      position: {\n        x: 0,\n        y: 250\n      },\n      maxHeight: canvasHeight,\n      maxWidth: canvasWidth,\n      onClick: this.onTextClick,\n      onDoubleClick: this.onDoubleClick,\n      onMouseDown: this.onMouseDown,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 253\n      },\n      __self: this\n    }))), jsx(Path, {\n      key: 'hola',\n      x: 50,\n      y: 40,\n      data: dog,\n      fill: 'red',\n      scaleX: 0.1,\n      scaleY: 0.1,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 264\n      },\n      __self: this\n    }), jsx(TransformerComponent, {\n      resizeEnabled: true,\n      rotateEnabled: true,\n      borderEnabled: true,\n      onMount: this.onMount,\n      selectedShapeName: selectedTextBlock,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 272\n      },\n      __self: this\n    }))), showEditTextArea && textBlocks[selectedTextBlock].text && jsx(EditTextArea, {\n      onTextAreaClosed: onTextAreaClosed,\n      onTextAreaChanged: onTextChanged,\n      selectedtextblockid: selectedTextBlock,\n      value: textBlocks[selectedTextBlock].text,\n      style: editTextAreaProps,\n      maxWidth: canvasWidth,\n      maxHeight: canvasHeight,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 283\n      },\n      __self: this\n    }));\n  }\n\n}\n\nexport default Canvas;","map":{"version":3,"sources":["C:/Users/Lucas/Documents/quiltros/components/canvas/index.tsx"],"names":["Card","Elevation","jsx","Component","createRef","Layer","Stage","Path","BackgroundImage","EditTextArea","canvasStyle","CanvasText","TransformerComponent","dog","Canvas","backgroundImage","canvasHeight","canvasWidth","editTextAreaProps","editTextAreaValue","onTextAreaClosed","showEditTextArea","targetToRestore","img","newHeight","newWidth","canvas","document","createElement","height","width","ctx","getContext","Promise","resolve","reject","drawImage","dataurl","toDataURL","newImage","Image","src","addEventListener","image","state","imageHeight","imageWidth","resizeImageHeight","e","cancelBubble","selectedTextBlock","target","name","props","onTextBlockSelected","currentTarget","forEach","el","canvasRef","current","show","draw","setState","hide","transformerRef","evt","id","attrs","hideElements","x","y","absolutePosition","left","top","container","getBoundingClientRect","areaPosition","text","color","fill","fontFamily","fontSize","lineHeight","padding","textAlign","align","transformOrigin","showElements","ref","componentDidUpdate","prevProps","getResizedImage","render","canvasTexts","onRef","onTextChanged","textBlocks","ONE","handleStageMouseDown","Object","values","map","textBlock","onTextClick","onDoubleClick","onMouseDown","onMount"],"mappings":"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","sourcesContent":["/** @jsx jsx */\r\nimport { Card, Elevation } from '@blueprintjs/core';\r\nimport { jsx } from '@emotion/core';\r\nimport { KonvaEventObject } from 'konva/types/Node';\r\nimport Konva from 'konva'\r\nimport React, { Component, createRef, RefObject } from 'react';\r\nimport { Layer, Stage, Path } from 'react-konva';\r\nimport { Image as ImageKonva } from 'react-konva';\r\n\r\nimport { ICanvasTexts } from '../../pages';\r\nimport { ITextBlocksConfigPanelState } from '../LeftSideBar/TextBlocksCreator/panel';\r\nimport BackgroundImage from './BackgroundImage';\r\nimport EditTextArea from './TextArea';\r\nimport { canvasStyle } from './style';\r\nimport CanvasText from './Text';\r\nimport TransformerComponent from './Transformer';\r\nimport { dog } from '../../assets/icons'\r\n\r\ninterface IAppProps {\r\n  onRef: RefObject<any>;\r\n  canvasRef: RefObject<any>;\r\n  onTextBlockSelected: (arg1: string) => void;\r\n  image: HTMLImageElement | null;\r\n  canvasTexts: ICanvasTexts;\r\n  onTextChanged: (arg1: string, arg2: string) => void;\r\n  currentCanvasText: ITextBlocksConfigPanelState;\r\n}\r\n\r\ninterface IAppState {\r\n  showEditTextArea: boolean;\r\n  backgroundImage: HTMLImageElement | null;\r\n  editTextAreaProps: any;\r\n  onTextAreaClosed: () => void;\r\n  targetToRestore: any[];\r\n  editTextAreaValue: string;\r\n}\r\nclass Canvas extends Component<IAppProps, IAppState> {\r\n  state = {\r\n    backgroundImage: null,\r\n    canvasHeight: 750,\r\n    canvasWidth: 500,\r\n    editTextAreaProps: {},\r\n    editTextAreaValue: '',\r\n    onTextAreaClosed: () => null,\r\n    showEditTextArea: false,\r\n    targetToRestore: []\r\n  };\r\n\r\n  transformerRef = createRef<any>();\r\n\r\n  resizeImageHeight = (img: HTMLImageElement, newHeight: number, newWidth: number): Promise<HTMLImageElement> => {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.height = newHeight;\r\n    canvas.width = newWidth;\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx) {\r\n      return Promise.resolve(img);\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      ctx.drawImage(img, 0, 0);\r\n      ctx.drawImage(img, 0, 0, newWidth, newHeight);\r\n      const dataurl = canvas.toDataURL('image/png');\r\n\r\n      const newImage = new Image();\r\n      newImage.src = dataurl;\r\n      newImage.addEventListener('load', () => {\r\n        resolve(newImage);\r\n      });\r\n      newImage.addEventListener('error', () => {\r\n        reject(img);\r\n      });\r\n    });\r\n  };\r\n\r\n  getResizedImage = (image: HTMLImageElement) => {\r\n    const { height, width } = image;\r\n    const { canvasHeight, canvasWidth } = this.state;\r\n    let imageHeight = height;\r\n    let imageWidth = width;\r\n    // Resize to go over the canvas height\r\n    imageWidth = imageWidth * (canvasHeight / imageHeight);\r\n    imageHeight = canvasHeight;\r\n\r\n    // Resize to go over the canvas width\r\n    if (canvasWidth > imageWidth) {\r\n      imageHeight = imageHeight * (canvasWidth / imageWidth);\r\n      imageWidth = canvasWidth;\r\n    }\r\n    return this.resizeImageHeight(image, imageHeight, imageWidth);\r\n  };\r\n\r\n  async componentDidUpdate(prevProps: any) {\r\n    const { image } = this.props;\r\n    if (image && image !== prevProps.image) {\r\n      const backgroundImage = await this.getResizedImage(image);\r\n      this.setState({ backgroundImage });\r\n    }\r\n  }\r\n\r\n  onTextClick = (e:Konva.KonvaEventObject<MouseEvent>): void => {\r\n    e.cancelBubble = true;\r\n    const selectedTextBlock = e.target.name();\r\n    this.props.onTextBlockSelected(selectedTextBlock);\r\n  };\r\n\r\n  handleStageMouseDown = (e: Konva.KonvaEventObject<MouseEvent>) => {\r\n    const showEditTextArea = false;\r\n    let selectedTextBlock = '';\r\n    const { currentTarget } = e;\r\n    const { targetToRestore } = this.state;\r\n    const { onTextBlockSelected } = this.props;\r\n    /*const clickedOnStage = target === currentTarget.getStage();\r\n    //const clickedOnTransformer =\r\n    //  target.getParent() && target.getParent().className === 'Transformer';\r\n    //const hasNoName = Boolean(target.name()); // If the thing we are clicking has no name\r\n    const isTextNode = typeof e.currentTarget.stat === 'function'; // TODO: maybe remove this?\r\n    if (isTextNode) {\r\n      selectedTextBlock = e.target.name;\r\n    }*/\r\n\r\n    if (targetToRestore) {\r\n      targetToRestore.forEach((el: any) => {\r\n        const canvasRef = this.props.canvasRef.current!;\r\n        el.show();\r\n        canvasRef.draw();\r\n      });\r\n    }\r\n\r\n    this.setState(\r\n      {\r\n        showEditTextArea\r\n      },\r\n      () => onTextBlockSelected(selectedTextBlock)\r\n    );\r\n  };\r\n\r\n  showElements = (currentTarget: any) => () => {\r\n    this.setState(\r\n      {\r\n        showEditTextArea: false\r\n      },\r\n      () => {\r\n        currentTarget.hide();\r\n        const transformerRef = this.transformerRef.current!;\r\n        const canvasRef = this.props.canvasRef.current!;\r\n        currentTarget.show();\r\n        transformerRef.show();\r\n        canvasRef.draw();\r\n      }\r\n    );\r\n  };\r\n\r\n  hideElements = (currentTarget: any) => {\r\n    currentTarget.hide();\r\n    const transformerRef = this.transformerRef.current!;\r\n    const canvasRef = this.props.canvasRef.current!;\r\n    currentTarget.hide();\r\n    transformerRef.hide();\r\n    canvasRef.draw();\r\n  };\r\n\r\n  onMouseDown = (evt: KonvaEventObject<MouseEvent>): void => {\r\n    const { onTextBlockSelected } = this.props;\r\n    evt.cancelBubble = true;\r\n    const currentTarget: any = evt.target;\r\n    const { id } = currentTarget.attrs;\r\n    onTextBlockSelected(id);\r\n  };\r\n\r\n  onDoubleClick = (evt: KonvaEventObject<MouseEvent>): void => {\r\n    const currentTarget: any = evt.currentTarget;\r\n    const transformerRef = this.transformerRef.current!;\r\n    const canvasRef = this.props.canvasRef.current!;\r\n    this.hideElements(currentTarget);\r\n\r\n    // We will create a textarea absolutely positioned over the canvas\r\n    // And we will render it on a portal\r\n    // first we need to find position for textarea\r\n\r\n    // At first lets find position of text node relative to the stage:\r\n    const { x, y } = currentTarget.absolutePosition();\r\n    const { left, top } = canvasRef.container().getBoundingClientRect();\r\n\r\n    // so position of textarea will be the sum of positions above:\r\n    const areaPosition = {\r\n      x: left + x,\r\n      y: top + y\r\n    };\r\n\r\n    // Create textarea styles to match text on canvas as close as possible\r\n    // (Text rendering on canvas and on the textarea can be different\r\n    // and sometimes it is hard to make it 100% the same)\r\n    const targetToRestore = [currentTarget, transformerRef];\r\n    const showEditTextArea = true;\r\n    const editTextAreaValue = currentTarget.text();\r\n    const editTextAreaProps = {\r\n      color: currentTarget.fill() + '',\r\n      fontFamily: currentTarget.fontFamily() + '',\r\n      fontSize: currentTarget.fontSize() + 'px',\r\n      height: currentTarget.height() + 'px',\r\n      left: areaPosition.x + 'px',\r\n      lineHeight: currentTarget.lineHeight() + '',\r\n      padding: currentTarget.padding() + 'px',\r\n      textAlign: currentTarget.align() + '',\r\n      top: areaPosition.y + 'px',\r\n      transformOrigin: 'left top',\r\n      width: currentTarget.width() + 5 + 'px'\r\n    };\r\n\r\n    const onTextAreaClosed = this.showElements(currentTarget);\r\n\r\n    this.setState({\r\n      editTextAreaProps,\r\n      editTextAreaValue,\r\n      onTextAreaClosed,\r\n      showEditTextArea,\r\n      targetToRestore\r\n    });\r\n  };\r\n\r\n  onMount = (ref : RefObject<any>) => {\r\n    this.transformerRef = ref;\r\n  };\r\n\r\n  render() {\r\n    const {\r\n      backgroundImage,\r\n      canvasHeight,\r\n      canvasWidth,\r\n      showEditTextArea,\r\n      editTextAreaProps,\r\n      onTextAreaClosed\r\n    } = this.state;\r\n    const { canvasTexts, onRef, onTextChanged } = this.props;\r\n    const { textBlocks, selectedTextBlock } = canvasTexts;\r\n    //const test = '<svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"venus\" class=\"svg-inline--fa fa-venus fa-w-9\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 288 512\"><path fill=\"currentColor\" d=\"M288 176c0-79.5-64.5-144-144-144S0 96.5 0 176c0 68.5 47.9 125.9 112 140.4V368H76c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h36v36c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12v-36h36c6.6 0 12-5.4 12-12v-40c0-6.6-5.4-12-12-12h-36v-51.6c64.1-14.5 112-71.9 112-140.4zm-224 0c0-44.1 35.9-80 80-80s80 35.9 80 80-35.9 80-80 80-80-35.9-80-80z\"></path></svg>'\r\n    return (\r\n      <Card elevation={Elevation.ONE} css={canvasStyle}>\r\n        {process.browser && (\r\n          <Stage\r\n            ref={onRef}\r\n            width={canvasWidth}\r\n            height={canvasHeight}\r\n            onClick={this.handleStageMouseDown}\r\n          >\r\n            <BackgroundImage\r\n              backgroundImage={backgroundImage}\r\n              canvasHeight={canvasHeight}\r\n              canvasWidth={canvasWidth}\r\n            />\r\n            <Layer>\r\n              {Object.values(textBlocks).map(textBlock => (\r\n                <CanvasText\r\n                  key={textBlock.id}\r\n                  {...textBlock}\r\n                  position={{ x: 0, y: 250 }}\r\n                  maxHeight={canvasHeight}\r\n                  maxWidth={canvasWidth}\r\n                  onClick={this.onTextClick}\r\n                  onDoubleClick={this.onDoubleClick}\r\n                  onMouseDown={this.onMouseDown}\r\n                />\r\n              ))}\r\n              <Path\r\n                key={'hola'}\r\n                x={50}\r\n                y={40}\r\n                data={dog}\r\n                fill={'red'}\r\n                scaleX={0.1}\r\n                scaleY={0.1} />\r\n              <TransformerComponent\r\n                resizeEnabled\r\n                rotateEnabled={true}\r\n                borderEnabled\r\n                onMount={this.onMount}\r\n                selectedShapeName={selectedTextBlock}\r\n              />\r\n            </Layer>\r\n          </Stage>\r\n        )}\r\n        {showEditTextArea && textBlocks[selectedTextBlock].text && (\r\n          <EditTextArea\r\n            onTextAreaClosed={onTextAreaClosed}\r\n            onTextAreaChanged={onTextChanged}\r\n            selectedtextblockid={selectedTextBlock}\r\n            value={textBlocks[selectedTextBlock].text}\r\n            style={editTextAreaProps}\r\n            maxWidth={canvasWidth}\r\n            maxHeight={canvasHeight}\r\n          />\r\n        )}\r\n      </Card>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Canvas;\r\n"]},"metadata":{},"sourceType":"module"}